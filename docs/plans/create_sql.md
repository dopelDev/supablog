# Crear SQL (Supablog) — análisis y plan

## Qué cubre este documento

**Objetivo:** definir un esquema mínimo para un blog en Supabase con Auth (OAuth), posts (draft/published), comentarios, y archivos en Storage con control por RLS.

## Asunciones (para no “asumir intent” sin decirlo)

- Multi-author: cada usuario autenticado puede crear posts.
- Público: lectura de posts `published` por `anon`; drafts solo dueño.
- Comentarios: requieren login (no `anon`) y se leen solo si el post es “legible”.
- Archivos: bucket privado por defecto + policies para lectura controlada (o alternativa: signed URLs).

## Preguntas abiertas (deciden el SQL final)

- ¿Solo existe un Admin (single-author) o cualquiera puede publicar (multi-author)?
- ¿Quieres moderación/soft-delete para comentarios?
- ¿Los archivos deben ser públicos por policy o siempre por signed URL?

## Checklist rápido

- Auth OAuth2 (Google + Microsoft)
- Tablas: `public.profiles`, `public.posts`, `public.comments`, `public.files`
- `posts.summary` para tarjetas
- RLS (Row Level Security) para evitar exposición accidental

---

## 0) Antes de tocar SQL: qué hace Supabase por ti

Supabase ya trae:

- Una tabla interna de auth: `auth.users`
- Un `auth.uid()` disponible en SQL para saber quién es el usuario logueado
- Providers OAuth configurables desde el dashboard

Tu tabla `users` “extra” normalmente se llama **`profiles`** para guardar _info pública_ y _metadata_ que no es estrictamente auth.

---

## 1) Crear proyecto y obtener la DB lista

1. Entra a Supabase → **New project**
2. Elige organización, nombre, password de DB, región
3. Espera a que termine el provisioning

---

## 2) Activar OAuth (Google + Microsoft)

### 2.1 Google

1. Supabase Dashboard → **Authentication → Providers**
2. Activa **Google**
3. Pega:
   - Client ID
   - Client Secret

4. Configura redirect URLs (Supabase te muestra cuáles usar)

En Google Cloud Console:

- Crea OAuth Client (Web)
- Agrega los redirect URLs que Supabase indica

### 2.2 Microsoft

1. Supabase → **Authentication → Providers**
2. Activa **Azure (Microsoft)**
3. Pega Client ID / Secret
4. Configura redirect URLs

En Azure Portal (Entra ID):

- App registration
- Redirect URIs (los de Supabase)
- Crea secret

> Resultado: el login lo maneja Supabase, tú solo llamas `supabase.auth.signInWithOAuth({ provider: 'google' })` o `'azure'`.

---

## 3) Crear Storage bucket para archivos

1. Supabase → **Storage**
2. **Create bucket**
   - nombre: `blog-files`
   - Público: **NO** (recomendado)

3. Luego daremos permisos vía políticas (RLS de storage)

---

## 4) Crear tablas en SQL (schema base)

Ve a **SQL Editor** y crea esto (puedes pegarlo en un solo run).

### 4.1 Enum para estado de post

```sql
create type public.post_status as enum ('draft', 'published', 'archived');
```

### 4.2 Profiles (tu “users” extendido)

```sql
create table public.profiles (
  id uuid primary key references auth.users (id) on delete cascade,
  email text unique,
  display_name text,
  avatar_url text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

### 4.3 Posts

```sql
create table public.posts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles (id) on delete cascade,

  title text not null,
  summary text not null default '',
  content text not null default '',

  status public.post_status not null default 'draft',

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  published_at timestamptz
);
```

Nota (opcional, recomendado): para reducir “confianza en el cliente”, puedes considerar `user_id uuid not null default auth.uid()` y evitar el trigger `set_owner_id()`. Si mantienes el trigger, valida que tu policy de `insert` no dependa de que el cliente envíe `user_id`.

### 4.4 Comments

```sql
create table public.comments (
  id bigint generated by default as identity primary key,
  post_id bigint not null references public.posts (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,

  comment_text text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

Si no planeas editar comentarios, puedes omitir `updated_at` para reducir superficie.

### 4.5 Files (metadata + referencia a storage)

```sql
create table public.files (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles (id) on delete cascade,

  -- opcional: archivo puede o no estar ligado a un post
  post_id bigint references public.posts (id) on delete set null,

  bucket text not null default 'blog-files',
  object_path text not null,          -- ruta dentro del bucket (ej: userId/postId/uuid.png)
  file_name text not null,
  mime_type text,
  size_bytes bigint,

  created_at timestamptz not null default now()
);
```

### 4.6 Índices adicionales para optimización

```sql
-- POSTS: feed público (paginación + orden estable)
create index idx_posts_published_feed
on public.posts (published_at desc, id desc)
where status = 'published' and published_at is not null;

-- POSTS: dashboard del autor (orden estable)
create index idx_posts_user_updated_desc
on public.posts (user_id, updated_at desc, id desc);

-- COMMENTS: hilo de un post
create index idx_comments_post_created_desc
on public.comments (post_id, created_at desc, id desc);

-- FILES: por post (solo cuando aplica)
create index idx_files_post_created_desc
on public.files (post_id, created_at desc, id desc)
where post_id is not null;

-- FILES: por usuario (tu librería)
create index idx_files_user_created_desc
on public.files (user_id, created_at desc, id desc);

-- FILES: acelerar joins con storage.objects + evitar duplicados
alter table public.files
  add constraint files_object_path_unique unique (bucket, object_path);
```

---

## 5) Auto-crear profile cuando alguien se registra (trigger)

La idea: cuando Supabase crea un usuario en `auth.users`, tú creas su fila en `profiles`.

```sql
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
as $$
begin
  insert into public.profiles (id, email, display_name, avatar_url)
  values (
    new.id,
    new.email,
    coalesce(
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'name',
      split_part(new.email, '@', 1)  -- fallback al username del email
    ),
    coalesce(new.raw_user_meta_data->>'avatar_url', '')
  )
  on conflict (id) do nothing;

  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;

create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();
```

---

## 6) Mantener updated_at automáticamente (posts/profiles)

```sql
create or replace function public.touch_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute procedure public.touch_updated_at();

drop trigger if exists trg_posts_updated_at on public.posts;
create trigger trg_posts_updated_at
before update on public.posts
for each row execute procedure public.touch_updated_at();

drop trigger if exists trg_comments_updated_at on public.comments;
create trigger trg_comments_updated_at
before update on public.comments
for each row execute procedure public.touch_updated_at();
```

Opcional: asegurar `user_id` en inserts de posts (no confíes en el cliente):

```sql
create or replace function public.set_owner_id()
returns trigger
language plpgsql
as $$
begin
  if new.user_id is null then
    new.user_id := auth.uid();
  end if;
  return new;
end;
$$;

drop trigger if exists trg_posts_owner on public.posts;
create trigger trg_posts_owner
before insert on public.posts
for each row execute procedure public.set_owner_id();
```

> Si prefieres “forzar” siempre el dueño, cambia el bloque por `new.user_id := auth.uid();`.

Opcional: setear `published_at` cuando pasa a published:

```sql
create or replace function public.set_published_at()
returns trigger
language plpgsql
as $$
begin
  if new.status = 'published' and old.status <> 'published' then
    new.published_at = now();
  end if;
  if new.status <> 'published' then
    new.published_at = null;
  end if;
  return new;
end;
$$;

drop trigger if exists trg_posts_published_at on public.posts;
create trigger trg_posts_published_at
before update on public.posts
for each row execute procedure public.set_published_at();
```

Opcional (modo pro): bloquear cambios de `status` salvo vía RPC:

```sql
create or replace function public.block_status_change()
returns trigger
language plpgsql
as $$
begin
  if new.status <> old.status then
    if coalesce(current_setting('app.allow_status_change', true), '') <> 'on' then
      raise exception using
        errcode = 'P0001',
        message = 'status change not allowed';
    end if;
  end if;
  return new;
end;
$$;

drop trigger if exists trg_block_status_change on public.posts;
create trigger trg_block_status_change
before update on public.posts
for each row execute procedure public.block_status_change();
```

Helper para validar si un post se puede publicar (opcional, pero recomendado):

```sql
create or replace function public.post_is_publishable(p_id bigint)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.posts p
    where p.id = p_id
      and p.user_id = auth.uid()
      and length(trim(p.title)) >= 3
      and length(trim(p.summary)) >= 10
      and length(trim(p.content)) >= 20
      and p.status <> 'archived'
  );
$$;
```

> Si agregas `deleted_at`, añade `and p.deleted_at is null` en la función.

RPC `publish_post` (idempotente + validaciones + error claro):

```sql
create or replace function public.publish_post(p_post_id bigint)
returns void
language plpgsql
security invoker
as $$
begin
  perform set_config('app.allow_status_change', 'on', true);

  -- idempotente: si ya está publicado, no hace nada
  if exists (
    select 1
    from public.posts
    where id = p_post_id
      and user_id = auth.uid()
      and status = 'published'
  ) then
    return;
  end if;

  if not public.post_is_publishable(p_post_id) then
    raise exception using
      errcode = 'P0001',
      message = 'cannot publish: not owner or fails validation (title/summary/content/status)';
  end if;

  update public.posts
  set status = 'published'
  where id = p_post_id
    and user_id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot publish: post not found or not allowed';
  end if;
end;
$$;
```

RPC `archive_post` (idempotente):

```sql
create or replace function public.archive_post(p_post_id bigint)
returns void
language plpgsql
security invoker
as $$
begin
  perform set_config('app.allow_status_change', 'on', true);

  -- idempotente: si ya está archivado, no hace nada
  if exists (
    select 1
    from public.posts
    where id = p_post_id
      and user_id = auth.uid()
      and status = 'archived'
  ) then
    return;
  end if;

  update public.posts
  set status = 'archived'
  where id = p_post_id
    and user_id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot archive: post not found or not allowed';
  end if;
end;
$$;
```

RPC `unpublish_post` (volver a draft) — opcional:

```sql
create or replace function public.unpublish_post(p_post_id bigint)
returns void
language plpgsql
security invoker
as $$
begin
  perform set_config('app.allow_status_change', 'on', true);

  update public.posts
  set status = 'draft'
  where id = p_post_id
    and user_id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot unpublish: post not found or not allowed';
  end if;
end;
$$;
```

## 6.x RPCs para Files (attachments + avatar)

Si vas a tratar `files.post_id` y `profiles.avatar_url` como **acciones** (no “updates libres”), la idea es:

- dar `update` en `files` pero **bloquearlo por trigger**, y
- permitir cambios solo desde RPCs (usando flags tipo `app.allow_*`).

Opcional (modo pro): bloquear updates en `files` salvo vía RPC (solo permite cambiar `post_id`):

```sql
create or replace function public.block_files_update()
returns trigger
language plpgsql
as $$
begin
  if coalesce(current_setting('app.allow_files_update', true), '') <> 'on' then
    raise exception using
      errcode = 'P0001',
      message = 'files update not allowed';
  end if;

  -- solo permitir cambiar post_id
  if new.user_id <> old.user_id
    or new.bucket <> old.bucket
    or new.object_path <> old.object_path
    or new.file_name <> old.file_name
    or new.mime_type is distinct from old.mime_type
    or new.size_bytes is distinct from old.size_bytes
    or new.created_at <> old.created_at then
    raise exception using
      errcode = 'P0001',
      message = 'only post_id can be updated';
  end if;

  -- si se está adjuntando, el post debe ser tuyo
  if new.post_id is not null and not exists (
    select 1
    from public.posts p
    where p.id = new.post_id
      and p.user_id = auth.uid()
  ) then
    raise exception using
      errcode = 'P0001',
      message = 'cannot attach file: post not found or not owned';
  end if;

  return new;
end;
$$;

drop trigger if exists trg_block_files_update on public.files;
create trigger trg_block_files_update
before update on public.files
for each row execute procedure public.block_files_update();
```

RPC para adjuntar un archivo a tu post (idempotente):

```sql
create or replace function public.attach_file_to_post(p_file_id bigint, p_post_id bigint)
returns void
language plpgsql
security invoker
as $$
begin
  perform set_config('app.allow_files_update', 'on', true);

  if not exists (
    select 1
    from public.posts p
    where p.id = p_post_id
      and p.user_id = auth.uid()
  ) then
    raise exception using
      errcode = 'P0001',
      message = 'cannot attach: post not found or not owned';
  end if;

  if exists (
    select 1
    from public.files f
    where f.id = p_file_id
      and f.user_id = auth.uid()
      and f.post_id is not null
      and f.post_id <> p_post_id
  ) then
    raise exception using
      errcode = 'P0001',
      message = 'cannot attach: file already attached to another post';
  end if;

  update public.files
  set post_id = p_post_id
  where id = p_file_id
    and user_id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot attach: file not found or not owned';
  end if;
end;
$$;
```

RPC para desadjuntar (volver `post_id` a null):

```sql
create or replace function public.detach_file_from_post(p_file_id bigint)
returns void
language plpgsql
security invoker
as $$
begin
  perform set_config('app.allow_files_update', 'on', true);

  update public.files
  set post_id = null
  where id = p_file_id
    and user_id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot detach: file not found or not owned';
  end if;
end;
$$;
```

Opcional (modo pro): bloquear cambios de `profiles.avatar_url` salvo vía RPC:

```sql
create or replace function public.block_avatar_url_change()
returns trigger
language plpgsql
as $$
begin
  if new.avatar_url is distinct from old.avatar_url then
    if coalesce(current_setting('app.allow_avatar_change', true), '') <> 'on' then
      raise exception using
        errcode = 'P0001',
        message = 'avatar change not allowed';
    end if;
  end if;
  return new;
end;
$$;

drop trigger if exists trg_block_avatar_url_change on public.profiles;
create trigger trg_block_avatar_url_change
before update on public.profiles
for each row execute procedure public.block_avatar_url_change();
```

RPC para setear tu avatar desde un `files.id` (solo imágenes, no adjunto a post):

```sql
create or replace function public.set_profile_avatar_from_file(p_file_id bigint)
returns text
language plpgsql
security invoker
as $$
declare
  v_object_path text;
begin
  select f.object_path
  into v_object_path
  from public.files f
  where f.id = p_file_id
    and f.user_id = auth.uid()
    and f.post_id is null
    and coalesce(f.mime_type, '') like 'image/%';

  if v_object_path is null then
    raise exception using
      errcode = 'P0001',
      message = 'cannot set avatar: file not found, not owned, not image, or attached to post';
  end if;

  perform set_config('app.allow_avatar_change', 'on', true);

  update public.profiles
  set avatar_url = v_object_path
  where id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot set avatar: profile not found';
  end if;

  return v_object_path;
end;
$$;
```

RPC para limpiar tu avatar (deja `avatar_url = null`):

```sql
create or replace function public.clear_profile_avatar()
returns void
language plpgsql
security invoker
as $$
begin
  perform set_config('app.allow_avatar_change', 'on', true);

  update public.profiles
  set avatar_url = null
  where id = auth.uid();

  if not found then
    raise exception using
      errcode = 'P0001',
      message = 'cannot clear avatar: profile not found';
  end if;
end;
$$;
```

---

## 7) Activar RLS y políticas (lo que te evita el apocalipsis)

### 7.1 Habilitar RLS

```sql
alter table public.profiles enable row level security;
alter table public.posts enable row level security;
alter table public.comments enable row level security;
alter table public.files enable row level security;

revoke all on table public.profiles from anon, authenticated;
revoke all on table public.posts from anon, authenticated;
revoke all on table public.comments from anon, authenticated;
revoke all on table public.files from anon, authenticated;

-- Permisos mínimos (las policies RLS siguen aplicando a nivel fila)
grant select on public.posts to anon, authenticated;
grant insert, update, delete on public.posts to authenticated;
grant usage, select on sequence public.posts_id_seq to authenticated;

grant select on public.comments to anon, authenticated;
grant insert, delete on public.comments to authenticated;
grant usage, select on sequence public.comments_id_seq to authenticated;

grant select on public.files to anon, authenticated;
grant insert, update, delete on public.files to authenticated;
grant usage, select on sequence public.files_id_seq to authenticated;

grant select, update on public.profiles to authenticated;
```

### 7.2 Profiles (privado + vista pública)

**Vista pública (solo campos seguros):**

```sql
create or replace view public.public_profiles as
select id, display_name, avatar_url
from public.profiles;

grant select on public.public_profiles to anon, authenticated;
```

**Policies en profiles (solo dueño):**

```sql
create policy "profiles: read own"
on public.profiles for select
using (id = auth.uid());
```

**Actualizar solo tu propio profile:**

```sql
create policy "profiles: update own"
on public.profiles for update
using (id = auth.uid())
with check (id = auth.uid());
```

### 7.3 Posts policies (draft privado, published público)

**Leer posts publicados (público):**

```sql
create policy "posts: read published"
on public.posts for select
using (status = 'published');
```

**Leer tus propios posts (incluye drafts):**

```sql
create policy "posts: read own"
on public.posts for select
using (user_id = auth.uid());
```

**Crear/editar/borrar solo tus posts:**

```sql
create policy "posts: insert own"
on public.posts for insert
with check (
  user_id = auth.uid()
  and status = 'draft'
  and published_at is null
);

create policy "posts: update own"
on public.posts for update
using (user_id = auth.uid())
with check (user_id = auth.uid());

create policy "posts: delete own"
on public.posts for delete
using (user_id = auth.uid());
```

### 7.4 Helpers para reglas repetidas

```sql
create or replace function public.can_read_post(p_id bigint)
returns boolean
language sql
stable
as $$
  select exists (
    select 1 from public.posts p
    where p.id = p_id
      and (p.status = 'published' or p.user_id = auth.uid())
  );
$$;
```

### 7.5 Comments policies

**Leer comentarios solo de posts permitidos** (publicados o tuyos)

```sql
create policy "comments: read allowed posts"
on public.comments for select
using (public.can_read_post(comments.post_id));
```

**Crear comentario: solo si el post es published** (o si eres dueño del post)

```sql
create policy "comments: insert on allowed posts"
on public.comments for insert
with check (
  user_id = auth.uid()
  and public.can_read_post(comments.post_id)
);

create policy "comments: delete own"
on public.comments for delete
using (user_id = auth.uid());
```

### 7.6 Files policies

**Leer archivos si:**

- El archivo pertenece a un post publicado, o
- El archivo es tuyo, o
- El archivo está ligado a tu post (aunque sea draft)

```sql
create policy "files: read allowed"
on public.files for select
using (
  user_id = auth.uid()
  OR (
    post_id is not null
    and public.can_read_post(files.post_id)
  )
);

create policy "files: insert own"
on public.files for insert
with check (
  user_id = auth.uid()
  and split_part(object_path, '/', 1) = auth.uid()::text
  and (
    post_id is null
    or exists (
      select 1
      from public.posts p
      where p.id = files.post_id
        and p.user_id = auth.uid()
    )
  )
);

create policy "files: update own"
on public.files for update
using (user_id = auth.uid())
with check (user_id = auth.uid());

create policy "files: delete own"
on public.files for delete
using (user_id = auth.uid());
```

---

## 8) Storage policies (para el bucket `blog-files`)

Esto se hace en SQL también, pero ojo: Storage usa tablas internas como `storage.objects`.

### 8.1 Permitir subir a tu propia carpeta

Estrategia simple: guardar objetos con path tipo:
`{userId}/{postId?}/{uuid}-{filename}`

**Insert (upload) solo si el primer folder = tu uid:**

```sql
create policy "storage: upload to own folder"
on storage.objects for insert
to authenticated
with check (
  bucket_id = 'blog-files'
  and split_part(name, '/', 1) = auth.uid()::text
);
```

**Read: permitir leer si es tuyo:**

```sql
create policy "storage: read own"
on storage.objects for select
to authenticated
using (
  bucket_id = 'blog-files'
  and split_part(name, '/', 1) = auth.uid()::text
);
```

**Read: permitir leer archivos de posts publicados** (para que los usuarios puedan ver imágenes/archivos de posts públicos):

```sql
create policy "storage: read published post files"
on storage.objects for select
to anon, authenticated
using (
  bucket_id = 'blog-files'
  and exists (
    select 1 from public.files f
    join public.posts p on p.id = f.post_id
    where f.object_path = storage.objects.name
      and f.bucket = storage.objects.bucket_id
      and p.status = 'published'
      and f.post_id is not null
  )
);
```

**Read: permitir leer avatars públicos** (si `profiles.avatar_url` apunta a un `object_path` en este bucket):

```sql
create policy "storage: read public avatars"
on storage.objects for select
to anon, authenticated
using (
  bucket_id = 'blog-files'
  and exists (
    select 1
    from public.public_profiles pp
    where pp.id::text = split_part(storage.objects.name, '/', 1)
      and pp.avatar_url = storage.objects.name
  )
);
```

> Nota: Si prefieres mayor control, puedes generar **signed URLs** desde el backend o desde el cliente según tus reglas, en vez de permitir acceso directo a través de esta política.

---

## 9) Cómo encaja el flujo real (operaciones básicas)

### 9.0 Dónde ejecutar este SQL (Supabase local en Docker)

En este repo, Supabase corre vía `docker compose up -d` y expone:

- Studio: `http://localhost:54323` → **SQL Editor** (recomendado para pegar estos scripts)
- Postgres: `localhost:5432` (útil si prefieres `psql`)

### 9.1 Login

- Usuario hace OAuth (Google/Microsoft)
- Supabase crea fila en `auth.users`
- Trigger crea fila en `profiles`

### 9.2 Crear post

- Insert en `posts` con `user_id = auth.uid()`, `status='draft'`
- Guardas `title`, `summary`, `content`

### 9.3 Publicar post

- Publicar = llamar `rpc/publish_post`
- Archivar = llamar `rpc/archive_post`
- (Opcional) Despublicar = `rpc/unpublish_post` (volver a draft)
- Trigger opcional setea `published_at`

### 9.4 Subir archivo

1. Subes a Storage: `blog-files/{uid}/{postId}/{uuid-filename}`
2. Insert en `files` con:
   - `user_id=auth.uid()`
   - `post_id` (si aplica)
   - `object_path` = ese path

Opcional (recomendado): si subes primero y adjuntas después:

- Insert inicial en `files` con `post_id = null`
- Adjuntar: `POST /rest/v1/rpc/attach_file_to_post` con `{ "p_file_id": 1, "p_post_id": 123 }`
- Desadjuntar: `POST /rest/v1/rpc/detach_file_from_post` con `{ "p_file_id": 1 }`

Avatar (si usas Storage para el avatar):

- Sube a `blog-files/{uid}/avatar/{uuid-filename}`
- Insert en `files` con `post_id = null` y `mime_type = 'image/...'`
- Setear avatar: `POST /rest/v1/rpc/set_profile_avatar_from_file` con `{ "p_file_id": 1 }`
- Limpiar avatar: `POST /rest/v1/rpc/clear_profile_avatar` con `{ }`

### 9.5 Comentarios

- Insert solo si el post está publicado (o eres dueño)

---

## 10) Verificaciones rápidas (queries útiles)

- Ver posts publicados (público):

```sql
select id, title, summary, published_at
from public.posts
where status = 'published'
  and published_at is not null
order by published_at desc, id desc;
```

- Tus drafts:

```sql
select id, title, status, updated_at
from public.posts
where user_id = auth.uid()
order by updated_at desc, id desc;
```

- Archivos de un post:

```sql
select *
from public.files
where post_id = 123
order by created_at desc, id desc;
```

- Ver profile de un autor (público):

```sql
select id, display_name, avatar_url
from public.public_profiles
where id = 'uuid-del-autor';
```

### Checklist rápido de robustez RLS

- `revoke all` en tablas sensibles + RLS habilitado
- `public_profiles` para exponer solo campos públicos
- `files.object_path` validado contra `auth.uid()`
- RPCs para transiciones de status (publish/archive/unpublish) + trigger que bloquea cambios directos
- Helper `public.can_read_post()` para no duplicar reglas

---

## 11) Recomendaciones adicionales para producción

### 11.1 Soft deletes (opcional)

Si necesitas mantener historial en lugar de borrar físicamente, agrega un campo `deleted_at`:

```sql
-- Ejemplo para posts
alter table public.posts add column deleted_at timestamptz;

-- Ajustar políticas para excluir borrados
-- Ejemplo: modificar "posts: read published" para incluir:
-- using (status = 'published' and deleted_at is null)
```

### 11.2 Slug único para URLs amigables (opcional)

```sql
alter table public.posts add column slug text;

-- Crear índice para búsquedas por slug
create unique index idx_posts_slug_unique
on public.posts(slug)
where slug is not null;

-- Trigger para generar slug automáticamente desde title (opcional)
```

### 11.3 Versionado de posts (opcional)

Si necesitas historial de cambios:

```sql
create table public.post_versions (
  id bigint generated by default as identity primary key,
  post_id bigint not null references public.posts (id) on delete cascade,
  title text not null,
  summary text,
  content text not null,
  created_at timestamptz not null default now(),
  created_by uuid references public.profiles (id)
);
```

### 11.4 Validaciones adicionales

Considera agregar constraints para mejorar la integridad:

```sql
-- Validar que summary y content no estén vacíos al publicar
-- (puedes hacerlo vía trigger o en la aplicación)

-- Ya agregamos UNIQUE(object_path) en `public.files` para evitar duplicados y acelerar joins con Storage.
-- Si planeas múltiples buckets, considera cambiarlo a UNIQUE(bucket, object_path) y ajustar la policy de Storage.

-- Mantener coherencia: si un post es `published`, debe tener `published_at`
alter table public.posts
  add constraint posts_published_at_required
  check (status <> 'published' or published_at is not null);
```

---
